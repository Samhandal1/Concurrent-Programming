Samantha Handal - 260983914

The solution implemented uses only monitor(s) based on blocking synchronization, as the instructions indicate. In Java, monitors are implemented using synchronized blocks or methods, along with methods like wait(), notify(), and notifyAll() from the Object class. These mechanisms work together to ensure that concurrent execution does not lead to race conditions, deadlocks, or other synchronization issues. To avoid excessive CPU usage like when we spin, wait() pauses a thread until conditions change, while notify() and notifyAll() wake waiting threads to check if they can proceed.

In my implementation, the TrafficController class uses synchronized blocks to manage vehicles entering and exiting the road. The synchronized keyword is used to ensure that changes to the road's state (the current direction of traffic, the number of vehicles on the road) are atomic and thread-safe. Vehicles waiting to enter the road cannot enter immediately due to the current traffic direction or because the road is full. The wait() method is used to put these vehicles into a waiting state, releasing the lock on the TrafficController object and allowing other vehicles to enter or exit the road. Once the conditions change, either the traffic direction changes or space becomes available, notifyAll() is called to wake up all waiting vehicles. Then, each vehicle checks if it can now enter the road.

When the rate at which cars appear is close to the time it takes a car to cross a segment, my implementation gets stuck only allowing cars to enter from one side. To fix this so that the waiting queue at the other end doesn't become too long, I put a cap on the number of cars that can enter from the same side sequentially. This threshold is set to the number of new cars that could arrive during the total time it takes for one car to drive through the whole road. Once we reach this number, the entrance to the road is blocked until all the cars have exited, and the last car to exit changes the direction flow and resets the entry flag to allow cars to enter again. To apply this traffic flow switch, there must be a queue of cars waiting on the other side and the difference in waiting cars between each side is larger than our threshold, this is to make sure we aren't switching the flow uselessly.

Ref: https://www.cis.upenn.edu/~bcpierce/courses/629/papers/Java-tutorial/java/threads/monitors.html, class notes on monitors